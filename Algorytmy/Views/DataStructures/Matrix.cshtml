
@{
    ViewBag.Title = "Macierz";
}

<h2>Macierz</h2>
<p>
    Poniższa implementacja macierzy zawiera:
    <ul>
        <li>indekser do odczytu i zapisu poszczególnych elementów macierzy,</li>
        <li>dodawanie macierzy zrealizowane za pomocą operatora <span class="math">+</span>,</li>
        <li>odejmowanie macierzy zrealizowane za pomocą operatora <span class="math">-</span>,</li>
        <li>mnożenie macierzy zrealizowane za pomocą operatora <span class="math">*</span>,</li>
        <li>mnożenie macierzy zrealizowane przez skalar za pomocą operatora <span class="math">*</span>,</li>
        <li>potęgowanie macierzy (szybkie) zrealizowane za pomocą operatora <span class="math">^</span>.</li>
    </ul>
    Ponieważ wyniki działań na standardowym typie danych (long) mogą się w nim nie zmieścić
    macierze zapisują dane modulo <span class="math">10<sup>8</sup></span> (sto milionów).
</p>
<pre>
public class Matrix
{
    private int RowsCount { get; set; }
    private int ColumnsCount { get; set; }<br />
    private static int mod = 100000000;<br />
    private long[,] matrixData;<br />
    public Matrix()
        : this(1, 1)
    { }<br />
    public Matrix(int rows, int columns)
    {
        RowsCount = rows;
        ColumnsCount = columns;
        matrixData = new long[rows, columns];
        matrixData.Initialize();
    }<br />
    public long this[int row, int column]
    {
        get { return matrixData[row, column]; }
        set { matrixData[row, column] = value % mod; }
    }<br />
    public static Matrix operator +(Matrix a, Matrix b)
    {
        if (a.RowsCount != b.RowsCount || a.ColumnsCount != b.ColumnsCount)
            throw new ArgumentException("Matricies must be the same size to add them.");<br />
        var result = new Matrix(a.RowsCount, a.ColumnsCount);
        for (int i = 0; i < a.RowsCount; i++)
            for (int j = 0; j < a.ColumnsCount; j++)
                result[i, j] = a[i, j] + b[i, j];
        return result;
    }<br />
    public static Matrix operator -(Matrix a, Matrix b)
    {
        if (a.RowsCount != b.RowsCount || a.ColumnsCount != b.ColumnsCount)
            throw new ArgumentException("Matricies must be the same size to substract them.");<br />
        var result = new Matrix(a.RowsCount, a.ColumnsCount);
        for (int i = 0; i < a.RowsCount; i++)
            for (int j = 0; j < a.ColumnsCount; j++)
                result[i, j] = a[i, j] - b[i, j];
        return result;
    }<br />
    public static Matrix operator *(Matrix a, Matrix b)
    {
        if (a.ColumnsCount != b.RowsCount)
            throw new ArgumentException("Number of columns in the first matrix has to equal number of rows in the second matrix.");<br />
        var result = new Matrix(a.RowsCount, b.ColumnsCount);
        for (int r = 0; r < a.RowsCount; r++)
            for (int c = 0; c < b.ColumnsCount; c++)
                for (int i = 0; i < a.ColumnsCount; i++)
                    result[r, c] += (a[r, i] * b[i, c]) % mod;
        return result;
    }<br />
    public static Matrix operator *(Matrix a, long k)
    {
        var result = new Matrix(a.RowsCount, a.ColumnsCount);
        for (int i = 0; i < a.RowsCount; i++)
            for (int j = 0; j < a.ColumnsCount; j++)
                result[i, j] = a[i, j] * k;
        return result;
    }<br />
    public static Matrix operator *(long k, Matrix a)
    {
        return a * k;
    }<br />
    public static Matrix operator ^(Matrix matrix, int power)
    {
        if (power == 1)
            return matrix;<br />
        var m = (matrix ^ (power / 2));
        return power.Even() ? m * m : m * m * matrix;
    }
}
</pre>

